/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "myDSCBPdf.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 
#include "RooMath.h"

ClassImp(myDSCBPdf) 

 myDSCBPdf::myDSCBPdf(const char *name, const char *title, 
                        RooAbsReal& _x,
                        RooAbsReal& _m,
                        RooAbsReal& _s,
                        RooAbsReal& _aL,
                        RooAbsReal& _aH,
                        RooAbsReal& _nL,
                        RooAbsReal& _nH) :
   RooAbsPdf(name,title), 
   x("x","x",this,_x),
   m("m","m",this,_m),
   s("s","s",this,_s),
   aL("aL","aL",this,_aL),
   aH("aH","aH",this,_aH),
   nL("nL","nL",this,_nL),
   nH("nH","nH",this,_nH)
 { 
 } 


 myDSCBPdf::myDSCBPdf(const myDSCBPdf& other, const char* name) :  
   RooAbsPdf(other,name), 
   x("x",this,other.x),
   m("m",this,other.m),
   s("s",this,other.s),
   aL("aL",this,other.aL),
   aH("aH",this,other.aH),
   nL("nL",this,other.nL),
   nH("nH",this,other.nH)
 { 
 } 



/* Double_t myDSCBPdf::evaluate() const 
 { 
   if( x<=m-fabs(aL)*s ){
      return pow(nL/fabs(aL),nL)*TMath::Exp(-pow(fabs(aL),2)/2)/pow((m-x)/s+nL-fabs(aL)/fabs(aL),nL);
   }
   //else if( x>=m+fabs(aH)*s ){
   //   return pow(nH/fabs(aH),nH)*TMath::Exp(-pow(fabs(aH),2)/2)/pow((m-x)/s+nH-fabs(aH)/fabs(aH),nH);
   //}
   else{
      return TMath::Exp(-pow((x-m)/s,2)/2);
   }
   
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
   //return 1.0 ; 
   
   
   
 } */
//_____________________________________________________________________________
Double_t myDSCBPdf::ApproxErf(Double_t arg) const 
{
  static const double erflim = 5.0;
  if( arg > erflim )
    return 1.0;
  if( arg < -erflim )
    return -1.0;
  
  return RooMath::erf(arg);
}


//_____________________________________________________________________________
Double_t myDSCBPdf::evaluate() const {

  Double_t t = (x-m)/s;
  //if (aL < 0) t = -t;

  Double_t absAlphaL = fabs((Double_t)aL);
  Double_t absAlphaH = fabs((Double_t)aH);

  if (t < -absAlphaL) {
    Double_t a =  TMath::Power(nL/absAlphaL,nL)*exp(-0.5*absAlphaL*absAlphaL);
    Double_t b = nL/absAlphaL - absAlphaL; 

    return a/TMath::Power(b - t, nL);
  }
  else if (t > absAlphaH) {
    Double_t a =  TMath::Power(nH/absAlphaH,nH)*exp(-0.5*absAlphaH*absAlphaH);
    Double_t b = nH/absAlphaH - absAlphaH; 

    return a/TMath::Power(b + t, nH);
  }
  else {
    return exp(-0.5*t*t);
  }
}


//_____________________________________________________________________________
Int_t myDSCBPdf::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const
{
  if( matchArgs(allVars,analVars,x) )
    return 1 ;
  
  return 0;
}



//_____________________________________________________________________________
Double_t myDSCBPdf::analyticalIntegral(Int_t code, const char* rangeName) const
{
  static const double sqrtPiOver2 = 1.2533141373;
  static const double sqrt2 = 1.4142135624;

  (void)code;
  assert(code==1);
  double result = 0.0;
  bool useLogL = false;
  bool useLogH = false;
  
  if( fabs(nL-1.0) < 1.0e-05 ) useLogL = true;
  if( fabs(nH-1.0) < 1.0e-05 ) useLogH = true;
  
  double sig = fabs((Double_t)s);
  
  double tmin = (x.min(rangeName)-m)/sig;
  double tmax = (x.max(rangeName)-m)/sig;
  
  //if(aL < 0) {
  //  double tmp = tmin;
  //  tmin = -tmax;
  //  tmax = -tmp;
  //}

  double absAlphaL = fabs((Double_t)aL);
  double absAlphaH = fabs((Double_t)aH);
  
  if( tmin >= -absAlphaL && tmax <= absAlphaH ) { //Case 1 only Gaussian
    result += sig*sqrtPiOver2*(   ApproxErf(tmax/sqrt2)
                                - ApproxErf(tmin/sqrt2) );
  }
  else if( tmax <= -absAlphaL ) { //Case 2 only low end tail
    double a = TMath::Power(nL/absAlphaL,nL)*exp(-0.5*absAlphaL*absAlphaL);
    double b = nL/absAlphaL - absAlphaL;
    
    if(useLogL) {
      result += a*sig*( log(b-tmin) - log(b-tmax) );
    }
    else {
      result += a*sig/(1.0-nL)*(   1.0/(TMath::Power(b-tmin,nL-1.0))
                                 - 1.0/(TMath::Power(b-tmax,nL-1.0)) );
    }
  }
  else if( tmin >= absAlphaH ) { //Case 3 only high end tail
    double a = TMath::Power(nH/absAlphaH,nH)*exp(-0.5*absAlphaH*absAlphaH);
    double b = nH/absAlphaH - absAlphaH;
    
    if(useLogH) {
      result += a*sig*( log(b+tmax) - log(b+tmin) );
    }
    else {
      result += a*sig/(1.0-nH)*(   1.0/(TMath::Power(b+tmax,nH-1.0))
                                 - 1.0/(TMath::Power(b+tmin,nH-1.0)) );
    }
  }
  else if( tmax <= absAlphaH ) {//Case 4 no high end tail
    double a = TMath::Power(nL/absAlphaL,nL)*exp(-0.5*absAlphaL*absAlphaL);
    double b = nL/absAlphaL - absAlphaL;
    
    double term1 = 0.0;
    if(useLogL) {
      term1 = a*sig*(  log(b-tmin) - log(b+absAlphaL));
    }
    else {
      term1 = a*sig/(1.0-nL)*(   1.0/(TMath::Power(b-tmin,nL-1.0))
                               - 1.0/(TMath::Power(b+absAlphaL,nL-1.0)) );
    }
    
    double term2 = sig*sqrtPiOver2*(   ApproxErf(tmax/sqrt2)
                                     - ApproxErf(-absAlphaL/sqrt2) );
    
    
    result += term1 + term2;
  }
  else if( tmin >= -absAlphaL ) {//Case 5 no low end tail
    double a = TMath::Power(nH/absAlphaH,nH)*exp(-0.5*absAlphaH*absAlphaH);
    double b = nH/absAlphaH - absAlphaH;
    
    double term1 = 0.0;
    if(useLogH) {
      term1 = a*sig*(  log(b+tmax) - log(b+absAlphaH));
    }
    else {
      term1 = a*sig/(1.0-nH)*(   1.0/(TMath::Power(b+tmax,nH-1.0))
                               - 1.0/(TMath::Power(b+absAlphaH,nH-1.0)) );
    }
    
    double term2 = sig*sqrtPiOver2*(   ApproxErf(absAlphaH/sqrt2)
                                     - ApproxErf(tmin/sqrt2) );
    
    
    result += term1 + term2;
  }
  else {//Case 6 all three parts
    double a_L = TMath::Power(nL/absAlphaL,nL)*exp(-0.5*absAlphaL*absAlphaL);
    double b_L = nL/absAlphaL - absAlphaL;
    
    double term1 = 0.0;
    if(useLogL) {
      term1 = a_L*sig*(  log(b_L-tmin) - log(b_L+absAlphaL));
    }
    else {
      term1 = a_L*sig/(1.0-nL)*(   1.0/(TMath::Power(b_L-tmin,nL-1.0))
                                 - 1.0/(TMath::Power(b_L+absAlphaL,nL-1.0)) );
    }
    
    double a_H = TMath::Power(nH/absAlphaH,nH)*exp(-0.5*absAlphaH*absAlphaH);
    double b_H = nH/absAlphaH - absAlphaH;
    
    double term2 = 0.0;
    if(useLogH) {
      term2 = a_H*sig*(  log(b_H+tmax) - log(b_H+absAlphaH));
    }
    else {
      term2 = a_H*sig/(1.0-nH)*(   1.0/(TMath::Power(b_H+tmax,nH-1.0))
                                 - 1.0/(TMath::Power(b_H+absAlphaH,nH-1.0)) );
    }
    
    
    double term3 = sig*sqrtPiOver2*(   ApproxErf(absAlphaH/sqrt2)
                                     - ApproxErf(-absAlphaL/sqrt2) );
  
    result += term1 + term2 + term3;
  }
  
  return result;
}



//_____________________________________________________________________________
Int_t myDSCBPdf::getMaxVal(const RooArgSet& vars) const 
{
  // Advertise that we know the maximum of self for given (m0,alpha,n,sigma)
  RooArgSet dummy ;

  if (matchArgs(vars,dummy,x)) {
    return 1 ;  
  }
  return 0 ;  
}



//_____________________________________________________________________________
Double_t myDSCBPdf::maxVal(Int_t code) const
{
  (void)code;
  assert(code==1) ;

  // The maximum value for given (m0,alpha,n,sigma)
  return 1.0 ;
}


